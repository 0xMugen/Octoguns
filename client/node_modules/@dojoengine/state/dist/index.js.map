{"version":3,"sources":["../src/recs/index.ts","../src/utils/index.ts"],"sourcesContent":["import {\n    Component,\n    ComponentValue,\n    Entity,\n    Metadata,\n    Schema,\n    setComponent,\n} from \"@dojoengine/recs\";\nimport {\n    Clause,\n    ToriiClient,\n    EntityKeysClause,\n    PatternMatching,\n} from \"@dojoengine/torii-client\";\nimport { convertValues } from \"../utils\";\n\n/**\n * Fetches and synchronizes entities with their components. This is useful for initializing the world state.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An array of entities to synchronize.\n * @param limit - The maximum number of entities to fetch per request (default: 100).\n * @returns A promise that resolves when synchronization is complete.\n *\n * @example\n * // Fetch all entities and their components\n * const components = createClientComponents({ contractComponents });\n * await getSyncEntities(client, components, undefined);\n *\n * @example\n * // Fetch all entities and their components via a query\n * const components = createClientComponents({ contractComponents });\n * await getSyncEntities(client, components, entityKeyClause);\n *\n * This function fetches all entities and their components from the client, then\n * synchronizes the entities with the specified components. It uses the provided\n * EntityKeysClause (if any) to filter entities and the specified components to\n * determine which data to retrieve. The function continues fetching until all\n * matching entities have been retrieved, using the 'limit' parameter to control\n * the batch size of each request.\n */\nexport const getSyncEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause[],\n    limit: number = 100\n) => {\n    await getEntities(client, components, limit);\n    return await syncEntities(client, components, entityKeyClause);\n};\n\n/**\n * Fetches and synchronizes events with their models. This is useful for initializing the world state with event data.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param clause - An optional clause to filter events.\n * @param entityKeyClause - An array of entities to synchronize.\n * @param limit - The maximum number of events to fetch per request (default: 100).\n * @returns A promise that resolves when synchronization is complete.\n *\n * @example\n * // Fetch all events and their components\n * const components = createClientComponents({ contractComponents });\n * await getSyncEvents(client, components, undefined, entityKeyClause);\n *\n * @example\n * // Fetch all events and their components via a query\n * const components = createClientComponents({ contractComponents });\n * await getSyncEvents(client, components, clause, entityKeyClause);\n *\n * This function fetches all events and their components from the client, then\n * synchronizes the events with the specified components. It uses the provided\n * Clause (if any) to filter events and the specified components to determine\n * which data to retrieve. The function continues fetching until all matching\n * events have been retrieved, using the 'limit' parameter to control the batch\n * size of each request.\n */\nexport const getSyncEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    clause: Clause | undefined,\n    entityKeyClause: EntityKeysClause[],\n    limit: number = 100\n) => {\n    // Fetch events from the client\n    await getEvents(client, components, limit, clause);\n    // Synchronize the fetched events with the specified components\n    return await syncEvents(client, components, entityKeyClause);\n};\n\n/**\n * Fetches all entities and their components from the client.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param limit - The maximum number of entities to fetch per request (default: 100).\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntities(client, components, 100);\n *\n * This function performs paginated queries to fetch all entities and their components.\n */\nexport const getEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    limit: number = 100\n) => {\n    let cursor = 0;\n    let continueFetching = true;\n\n    while (continueFetching) {\n        const entities = await client.getAllEntities(limit, cursor);\n\n        setEntities(entities, components);\n\n        if (Object.keys(entities).length < limit) {\n            continueFetching = false;\n        } else {\n            cursor += limit;\n        }\n    }\n};\n\n/**\n * Fetches event messages from the client and synchronizes them with the specified components.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param limit - The maximum number of event messages to fetch per request (default: 100).\n * @param clause - An optional clause to filter event messages.\n */\nexport const getEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    limit: number = 100,\n    clause: Clause | undefined\n) => {\n    let offset = 0; // Initialize the offset for pagination\n    let continueFetching = true; // Flag to control the fetching loop\n\n    while (continueFetching) {\n        // Fetch event messages from the client with the specified limit and offset\n        const entities = await client.getEventMessages({\n            limit,\n            offset,\n            clause,\n        });\n\n        console.log(\"entities\", entities); // Log the fetched entities for debugging\n\n        // Synchronize the fetched entities with the specified components\n        setEntities(entities, components);\n\n        // Check if the number of fetched entities is less than the limit\n        if (Object.keys(entities).length < limit) {\n            continueFetching = false; // Stop fetching if fewer entities are returned\n        } else {\n            offset += limit; // Increment the offset for the next batch\n        }\n    }\n};\n\n/**\n * Fetches entities and their components from the client based on specified criteria.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions to fetch.\n * @param entityKeyClause - An optional EntityKeysClause to filter entities by their keys.\n * @param patternMatching - The pattern matching strategy for entity keys (default: \"FixedLen\").\n * @param limit - The maximum number of entities to fetch per request (default: 1000).\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntitiesQuery(client, components, undefined, \"FixedLen\", 1000);\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntitiesQuery(client, components, { Keys: { keys: [\"0x1\"], models: [\"Position\"] } }, \"FixedLen\", 1000);\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntitiesQuery(client, components, { HashedKeys: [\"0x1\"] }, \"FixedLen\", 1000);\n *\n * This function performs paginated queries to fetch all matching entities and their\n * components. It uses the provided EntityKeysClause (if any) to filter entities and\n * the specified components to determine which data to retrieve. The function continues\n * fetching until all matching entities have been retrieved, using the 'limit' parameter\n * to control the batch size of each request.\n */\nexport const getEntitiesQuery = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause,\n    patternMatching: PatternMatching = \"FixedLen\",\n    limit: number = 1000\n) => {\n    let cursor = 0;\n    let continueFetching = true;\n\n    while (continueFetching) {\n        const clause: Clause | null = entityKeyClause\n            ? {\n                  Keys: {\n                      keys:\n                          \"HashedKeys\" in entityKeyClause\n                              ? entityKeyClause.HashedKeys\n                              : entityKeyClause.Keys.keys,\n                      pattern_matching: patternMatching,\n                      models: [\n                          ...components.map((c) => c.metadata?.name as string),\n                      ],\n                  },\n              }\n            : null;\n\n        const fetchedEntities = await client.getEntities({\n            limit,\n            offset: cursor,\n            clause: clause || undefined,\n        });\n\n        setEntities(fetchedEntities, components);\n\n        if (Object.keys(fetchedEntities).length < limit) {\n            continueFetching = false;\n        } else {\n            cursor += limit;\n        }\n    }\n};\n\n/**\n * Sets up a subscription to sync entity updates.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An optional EntityKeysClause to filter entities.\n * @returns A promise that resolves with the subscription handler.\n * The handler can be used to cancel the subscription when needed.\n * @example\n * const sync = await getSyncEntities(client, components, entityKeyClause);\n * // later...\n * sync.cancel(); // cancel the subscription\n */\nexport const syncEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause[]\n) => {\n    return await client.onEntityUpdated(\n        entityKeyClause,\n        (fetchedEntities: any, data: any) => {\n            setEntities({ [fetchedEntities]: data }, components);\n        }\n    );\n};\n\n/**\n * Sets up a subscription to sync event messages.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An optional EntityKeysClause to filter entities.\n * @returns A promise that resolves with the subscription handler.\n * The handler can be used to cancel the subscription when needed.\n * @example\n * const sync = await syncEvents(client, components, entityKeyClause);\n * // later...\n * sync.cancel(); // cancel the subscription\n */\nexport const syncEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause[]\n) => {\n    return await client.onEventMessageUpdated(\n        entityKeyClause,\n        (fetchedEntities: any, data: any) => {\n            // Log the fetched entities and data for debugging purposes\n            console.log(\"fetchedEntities\", data);\n            // Update the local state with the fetched entities and their data\n            setEntities({ [fetchedEntities]: data }, components);\n        }\n    );\n};\n\n/**\n * Updates the components of entities in the local state.\n * @param entities - An array of entities with their updated component data.\n * @param components - An array of component definitions.\n */\nexport const setEntities = async <S extends Schema>(\n    entities: any,\n    components: Component<S, Metadata, undefined>[]\n) => {\n    for (let key in entities) {\n        if (!Object.hasOwn(entities, key)) {\n            continue;\n        }\n\n        for (let componentName in entities[key]) {\n            if (!Object.hasOwn(entities[key], componentName)) {\n                continue;\n            }\n            let recsComponent = Object.values(components).find(\n                (component) =>\n                    component.metadata?.namespace +\n                        \"-\" +\n                        component.metadata?.name ===\n                    componentName\n            );\n\n            if (recsComponent) {\n                try {\n                    setComponent(\n                        recsComponent,\n                        key as Entity,\n                        convertValues(\n                            recsComponent.schema,\n                            entities[key][componentName]\n                        ) as ComponentValue\n                    );\n                } catch (error) {\n                    console.warn(\n                        `Failed to set component ${recsComponent.metadata?.name} on ${key}`,\n                        error\n                    );\n                }\n            }\n        }\n    }\n};\n","import { Type as RecsType, Schema } from \"@dojoengine/recs\";\n\nexport function convertValues(schema: Schema, values: any) {\n    return Object.keys(schema).reduce<any>((acc, key) => {\n        if (!acc) {\n            acc = {};\n        }\n        const schemaType = schema[key];\n        const value = values[key];\n\n        if (value === null || value === undefined) {\n            acc[key] = value;\n            return acc;\n        }\n\n        if (value.type === \"enum\") {\n            acc[key] = value.value.option;\n            return acc;\n        }\n\n        switch (schemaType) {\n            case RecsType.StringArray:\n                if (value.type === \"array\" && value.value[0].type === \"enum\") {\n                    acc[key] = value.value.map(\n                        (item: any) => item.value.option\n                    );\n                } else {\n                    acc[key] = value.value.map((a: any) => {\n                        try {\n                            return BigInt(a.value);\n                        } catch (error) {\n                            console.warn(\n                                `Failed to convert ${a.value} to BigInt. Using string value instead.`\n                            );\n                            return a.value;\n                        }\n                    });\n                }\n                break;\n\n            case RecsType.String:\n                acc[key] = value.value;\n                break;\n\n            case RecsType.BigInt:\n                try {\n                    acc[key] = BigInt(value.value);\n                } catch (error) {\n                    console.warn(\n                        `Failed to convert ${value.value} to BigInt. Using string value instead.`\n                    );\n\n                    acc[key] = BigInt(`0x${value.value}`);\n                }\n                break;\n\n            case RecsType.Boolean:\n                acc[key] = value.value;\n                break;\n\n            case RecsType.Number:\n                acc[key] = Number(value.value);\n                break;\n\n            default:\n                if (typeof schemaType === \"object\" && value.type === \"struct\") {\n                    if (value.value instanceof Map) {\n                        const structValues = Object.fromEntries(value.value);\n                        acc[key] = convertValues(schemaType, structValues);\n                    } else {\n                        acc[key] = convertValues(schemaType, value.value);\n                    }\n                } else if (\n                    Array.isArray(schemaType) &&\n                    value.type === \"array\"\n                ) {\n                    acc[key] = value.value.map((item: any) =>\n                        convertValues(schemaType[0], item)\n                    );\n                } else {\n                    acc[key] = value.value;\n                }\n                break;\n        }\n\n        return acc;\n    }, {});\n}\n"],"mappings":"AAAA,OAMI,gBAAAA,MACG,mBCPP,OAAS,QAAQC,MAAwB,mBAElC,SAASC,EAAcC,EAAgBC,EAAa,CACvD,OAAO,OAAO,KAAKD,CAAM,EAAE,OAAY,CAACE,EAAKC,IAAQ,CAC5CD,IACDA,EAAM,CAAC,GAEX,IAAME,EAAaJ,EAAOG,CAAG,EACvBE,EAAQJ,EAAOE,CAAG,EAExB,GAAIE,GAAU,KACV,OAAAH,EAAIC,CAAG,EAAIE,EACJH,EAGX,GAAIG,EAAM,OAAS,OACf,OAAAH,EAAIC,CAAG,EAAIE,EAAM,MAAM,OAChBH,EAGX,OAAQE,EAAY,CAChB,KAAKN,EAAS,YACNO,EAAM,OAAS,SAAWA,EAAM,MAAM,CAAC,EAAE,OAAS,OAClDH,EAAIC,CAAG,EAAIE,EAAM,MAAM,IAClBC,GAAcA,EAAK,MAAM,MAC9B,EAEAJ,EAAIC,CAAG,EAAIE,EAAM,MAAM,IAAKE,GAAW,CACnC,GAAI,CACA,OAAO,OAAOA,EAAE,KAAK,CACzB,MAAgB,CACZ,eAAQ,KACJ,qBAAqBA,EAAE,KAAK,yCAChC,EACOA,EAAE,KACb,CACJ,CAAC,EAEL,MAEJ,KAAKT,EAAS,OACVI,EAAIC,CAAG,EAAIE,EAAM,MACjB,MAEJ,KAAKP,EAAS,OACV,GAAI,CACAI,EAAIC,CAAG,EAAI,OAAOE,EAAM,KAAK,CACjC,MAAgB,CACZ,QAAQ,KACJ,qBAAqBA,EAAM,KAAK,yCACpC,EAEAH,EAAIC,CAAG,EAAI,OAAO,KAAKE,EAAM,KAAK,EAAE,CACxC,CACA,MAEJ,KAAKP,EAAS,QACVI,EAAIC,CAAG,EAAIE,EAAM,MACjB,MAEJ,KAAKP,EAAS,OACVI,EAAIC,CAAG,EAAI,OAAOE,EAAM,KAAK,EAC7B,MAEJ,QACI,GAAI,OAAOD,GAAe,UAAYC,EAAM,OAAS,SACjD,GAAIA,EAAM,iBAAiB,IAAK,CAC5B,IAAMG,EAAe,OAAO,YAAYH,EAAM,KAAK,EACnDH,EAAIC,CAAG,EAAIJ,EAAcK,EAAYI,CAAY,CACrD,MACIN,EAAIC,CAAG,EAAIJ,EAAcK,EAAYC,EAAM,KAAK,OAGpD,MAAM,QAAQD,CAAU,GACxBC,EAAM,OAAS,QAEfH,EAAIC,CAAG,EAAIE,EAAM,MAAM,IAAKC,GACxBP,EAAcK,EAAW,CAAC,EAAGE,CAAI,CACrC,EAEAJ,EAAIC,CAAG,EAAIE,EAAM,MAErB,KACR,CAEA,OAAOH,CACX,EAAG,CAAC,CAAC,CACT,CD9CO,IAAMO,EAAkB,MAC3BC,EACAC,EACAC,EACAC,EAAgB,OAEhB,MAAMC,EAAYJ,EAAQC,EAAYE,CAAK,EACpC,MAAME,EAAaL,EAAQC,EAAYC,CAAe,GA6BpDI,EAAgB,MACzBN,EACAC,EACAM,EACAL,EACAC,EAAgB,OAGhB,MAAMK,EAAUR,EAAQC,EAAYE,EAAOI,CAAM,EAE1C,MAAME,EAAWT,EAAQC,EAAYC,CAAe,GAelDE,EAAc,MACvBJ,EACAC,EACAE,EAAgB,MACf,CACD,IAAIO,EAAS,EACTC,EAAmB,GAEvB,KAAOA,GAAkB,CACrB,IAAMC,EAAW,MAAMZ,EAAO,eAAeG,EAAOO,CAAM,EAE1DG,EAAYD,EAAUX,CAAU,EAE5B,OAAO,KAAKW,CAAQ,EAAE,OAAST,EAC/BQ,EAAmB,GAEnBD,GAAUP,CAElB,CACJ,EASaK,EAAY,MACrBR,EACAC,EACAE,EAAgB,IAChBI,IACC,CACD,IAAIO,EAAS,EACTH,EAAmB,GAEvB,KAAOA,GAAkB,CAErB,IAAMC,EAAW,MAAMZ,EAAO,iBAAiB,CAC3C,MAAAG,EACA,OAAAW,EACA,OAAAP,CACJ,CAAC,EAED,QAAQ,IAAI,WAAYK,CAAQ,EAGhCC,EAAYD,EAAUX,CAAU,EAG5B,OAAO,KAAKW,CAAQ,EAAE,OAAST,EAC/BQ,EAAmB,GAEnBG,GAAUX,CAElB,CACJ,EA4BaY,EAAmB,MAC5Bf,EACAC,EACAC,EACAc,EAAmC,WACnCb,EAAgB,MACf,CACD,IAAIO,EAAS,EACTC,EAAmB,GAEvB,KAAOA,GAAkB,CACrB,IAAMJ,EAAwBL,EACxB,CACI,KAAM,CACF,KACI,eAAgBA,EACVA,EAAgB,WAChBA,EAAgB,KAAK,KAC/B,iBAAkBc,EAClB,OAAQ,CACJ,GAAGf,EAAW,IAAKgB,GAAMA,EAAE,UAAU,IAAc,CACvD,CACJ,CACJ,EACA,KAEAC,EAAkB,MAAMlB,EAAO,YAAY,CAC7C,MAAAG,EACA,OAAQO,EACR,OAAQH,GAAU,MACtB,CAAC,EAEDM,EAAYK,EAAiBjB,CAAU,EAEnC,OAAO,KAAKiB,CAAe,EAAE,OAASf,EACtCQ,EAAmB,GAEnBD,GAAUP,CAElB,CACJ,EAcaE,EAAe,MACxBL,EACAC,EACAC,IAEO,MAAMF,EAAO,gBAChBE,EACA,CAACgB,EAAsBC,IAAc,CACjCN,EAAY,CAAE,CAACK,CAAe,EAAGC,CAAK,EAAGlB,CAAU,CACvD,CACJ,EAeSQ,EAAa,MACtBT,EACAC,EACAC,IAEO,MAAMF,EAAO,sBAChBE,EACA,CAACgB,EAAsBC,IAAc,CAEjC,QAAQ,IAAI,kBAAmBA,CAAI,EAEnCN,EAAY,CAAE,CAACK,CAAe,EAAGC,CAAK,EAAGlB,CAAU,CACvD,CACJ,EAQSY,EAAc,MACvBD,EACAX,IACC,CACD,QAASmB,KAAOR,EACZ,GAAK,OAAO,OAAOA,EAAUQ,CAAG,EAIhC,QAASC,KAAiBT,EAASQ,CAAG,EAAG,CACrC,GAAI,CAAC,OAAO,OAAOR,EAASQ,CAAG,EAAGC,CAAa,EAC3C,SAEJ,IAAIC,EAAgB,OAAO,OAAOrB,CAAU,EAAE,KACzCsB,GACGA,EAAU,UAAU,UAChB,IACAA,EAAU,UAAU,OACxBF,CACR,EAEA,GAAIC,EACA,GAAI,CACAE,EACIF,EACAF,EACAK,EACIH,EAAc,OACdV,EAASQ,CAAG,EAAEC,CAAa,CAC/B,CACJ,CACJ,OAASK,EAAO,CACZ,QAAQ,KACJ,2BAA2BJ,EAAc,UAAU,IAAI,OAAOF,CAAG,GACjEM,CACJ,CACJ,CAER,CAER","names":["setComponent","RecsType","convertValues","schema","values","acc","key","schemaType","value","item","a","structValues","getSyncEntities","client","components","entityKeyClause","limit","getEntities","syncEntities","getSyncEvents","clause","getEvents","syncEvents","cursor","continueFetching","entities","setEntities","offset","getEntitiesQuery","patternMatching","c","fetchedEntities","data","key","componentName","recsComponent","component","setComponent","convertValues","error"]}